<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <script src="http://d3js.org/d3.v4.js"></script>
    <script src="https://d3js.org/d3-queue.v3.min.js"></script>
    <script src="http://d3js.org/d3.hexbin.v0.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    
    <style>
      .states path {
        fill: #ddd;
        stroke: #000;
        stroke-width: 1px;
      }
      .hex-mesh path{
        stroke: white;
        stroke-opacity: 0;
        stroke-width: 0.8;
        fill-opacity: 0;
      }
      .hexagons path{
        stroke-width: 0.2;
        stroke: black;
      }
      
      div.tooltip {
        color: #222;
        background-color: #fff;
        padding: .5em;
        text-shadow: #f5f5f5 0 1px 0;
        border-radius: 20%;
      	border:1px solid;
        opacity: 0.9;
        position: absolute;
    }
    
    .hidden {
        display: none;
    }
    </style>
  </head>

  <body>

  <script>
  var width = 950,
      height = 500;

  var svg = d3.select('body')
    .append('svg')
    .attr('width', width)
    .attr('height', height+100);

  var projection = d3.geoMercator();
    
  var path = d3.geoPath()
    .projection(projection);

  var color = d3.scaleLinear()
    .range(['#fff ', '#e31a1c'])
    .domain([0, 20])
    .interpolate(d3.interpolateLab);

  var hexRadius = 5;
  var hexbin = d3.hexbin()
      .size([width, height])
      .radius(hexRadius);

  var states = svg.append('g')
    .attr('class', 'states');



    var tooltip = d3.select('body').append('div')
            .attr('class', 'hidden tooltip');	
    
  function render (geometry, data, hexcountries) {
    
    var color = d3.scaleLinear().domain([0,666666666])
                    .range([d3.rgb("#80d491"), d3.rgb('#00b730')]);;
    
    var color2 = d3.scaleLinear().domain([0,1,15,50])
                    .range([
                      d3.rgb("#ffffff"),
                      d3.rgb("#169900"),
                      d3.rgb("#e2ae12"), 
                      d3.rgb('#b70021')
                    ])
    								.interpolate(d3.interpolateHcl);
    
    states.selectAll('path')
    .data(geometry.features)
    .enter().append('path')
    .attr('d', path)
    .attr('fill-opacity', 1)
    .attr('stroke-opacity', 1)
    .attr('id',function(d) {
      return d.properties.name;
    })
    .style("fill", function(d) {
      var value = d.properties.pop_est;
      if (value) {
        return color(value);
      } else { 
        // si pas de valeur alors en gris
        return "#ccc";
      }
    })
    .on('mousemove', function(d) {
      var mouse = d3.mouse(svg.node()).map(function(d) {
        return parseInt(d);
      });
      tooltip.classed('hidden', false)
        .attr('style', 'left:' + (mouse[0] + 25) +
              'px; top:' + (mouse[1]) + 'px')
        .html(d.properties.name);
    })
    .on('mouseout', function() {
      tooltip.classed('hidden', true);
    });
    ;
    
    var coord =[]
    hexcountries.forEach(function(e){
      coord=coord.concat(JSON.parse(e.coordinates));
    });
    
    var coord = [[]]
    for(x=0;x<width+5;x+=hexRadius){
      for(y=0;y<height+10;y+=hexRadius){
        var element = document.elementFromPoint(x, y);
				if(element['id']!=""){
        	coord=coord.concat([[x-5,y-10,element['id']]])
        }
      } 
    }
    
  var hexagon = svg.append('g')
    .attr('class', 'hexagons');

  var mesh = svg.append('g')
    .attr('class', 'hex-mesh')
    .append('path')
      .attr('d', hexbin.mesh());
        
      hexagon.selectAll('path')
      .data(hexbin(coord))
    	.enter().append('path')
      .attr('transform', d => { return 'translate(' + d.x + ',' + d.y + ')'; })
      .attr('id',function(d) {
        return d[0][2];
      })
      .attr('fill-opacity', 0)
      .attr('stroke-opacity', 0)
      .attr('d', hexbin.hexagon())
      .transition()
        .attr('d', hexbin.hexagon(hexbin.radius()))
          
      var migrValue = 0

       
		d3.selectAll(".hexagons")
			.selectAll("path").each(function(d, i) {
				//console.log("hey",this.id, d);
      	var nom = this.id;
				data.forEach(function(e){
					if(e.name==nom)
					{
						migrValue=e.pessimistic;
					}
				});
				this.setAttribute("fill",color2(migrValue))
      	migrValue=0
			})
      .transition()
       .attr('fill-opacity', 1)
       .attr('stroke-opacity', 1)
    	 .delay(5000)
       .duration(1000);
    ;

    
		states.selectAll('path')
			.transition()
        .attr('fill-opacity', 0)
        .attr('stroke-opacity', 0)
    	  .delay(5000)
       	.duration(1000);
    
    var migCoords =[];
    var iMig=1;
    var jMig=1;
    /*for(i=0;i<d3.selectAll(".hexagons")
			.selectAll("path").size();i++){
      rayon=jMig*hexRadius
      theta=iMig*360/(6*jMig)
      xMig=500+2*rayon*Math.cos(theta)
      yMig=450+2*rayon*Math.sin(theta)
      migCoords=migCoords.concat([[xMig,yMig]])
      console.log(rayon,theta,iMig,jMig,xMig,yMig)
      iMig++;
      if(iMig==6*jMig){
        iMig=1;
        jMig++;
      }
    }*/
    
    xCenter = 150;
    yCenter = 350;
    var migCoords =[[xCenter,yCenter]];
    for(k=1;k<40;k++){
      for(i=0;i<6;i++){
        for(j=0;j<k;j++){
          rayon=2*k*hexRadius
          theta=(6*(j-1)+i)*2*Math.PI/(k*6)
          xMig=xCenter+rayon*Math.cos(theta)
          yMig=yCenter+rayon*Math.sin(theta)
          migCoords=migCoords.concat([[xMig,yMig]])
        }
      }
    }
    
    
    console.log(migCoords)
      var migId=0

    data.forEach(function(e){
      var cBug=["Cote d'Ivoire","Falkland Islands (Islas Malvinas)","Holy See (Vatican City)","Cocos (Keeling) Islands"]
      if(!cBug.includes(e.name)){
			var cName="#"+e.name
      var nbHex = hexagon.selectAll(cName).size();
        hexagon.selectAll(cName)
          .each(function(d,i){
          if(e.pessimistic>0){
            if(i<Math.max(1,nbHex*e.pessimistic/100)){
              d3.select(this).transition()
                .attr('transform', d => { return 'translate(' + migCoords[migId][0] + ',' + migCoords[migId][1] + ')'; })
                .delay(6000)
                .duration(10000);
            	migId++;
            }
          }
        })
      }
	});
  }
    
        
  d3.queue()
    .defer(d3.json, 'world.geojson')
  	.defer(d3.tsv, 'world_population.tsv')
  	.defer(d3.tsv, 'hexcountries.tsv')
    .awaitAll((err, results) => {
      if (err) { return console.error(err); }
      render(results[0], results[1], results[2]);
    });
    
    /*
		document.addEventListener('click', printMousePos, true);
    var country = []
    function printMousePos(event) {
      if(event.clientY>500) 
        country=[];
      else
      	country.push([event.clientX-7,event.clientY-7]);
      console.log(country)
    }*/

  </script>
  </body>
</html>
